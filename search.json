[{"title":"JS 中 Function 和 Object 的关系","url":"/blog/技术相关/JS-中-Function-和-Object-的关系/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/javascript.png\" width=\"65%\" height=\"65%\">\n\n> js 的世界很大，并不是只有对象\n\n这段时间在复习前端基础知识，遇到了下面这道面试题：\n```js\nvar F = function(){}\nvar f = new F()\nObject.prototype.a = function(){}\nFunction.prototype.b = function(){}\n\nconsole.log(f.a)\nconsole.log(f.b)\n```\n请问这段代码会输出什么？\n<!-- more -->\n打开浏览器控制台，将上面这段代码复制进去，回车，我们可以得到它的答案：\n```js\nƒ (){}\nundefined\n```\n细看我们可以发现这道题并不难，对于`f.a`，JavaScript 解释器会按照原型链的规则去查找 f 的 a 属性：\n1. 在 f 本身查找是否有 a 属性，显然没有，接下来将会进入 f 的原型链查找；\n1. 查找`f.__proto__`是否有 a 属性，而`f.__proto__ === F.prototype`，显然也没有；\n1. 继续查找`f.__proto__.__proto__`，即`F.prototype.__proto__`，而`F.prototype.__proto__ === Object.prototype`，可以发现`Object.prototype` 中有 a 属性。\n\n对于`f.b`，解释器会进行和上面一样的操作，但并不会在原型链中找到 b 属性， 因为`f.__proto__.__proto__.__proto__ === Object.prototype.__proto__ === null`，结束查找\n\n那么代码中的`Function.prototype.b = function(){}`能有什么作用呢？不难发现：\n```js\nconsole.log(F.b) // ƒ (){}\n// 甚至还有\nconsole.log(Object.b) // ƒ (){}\nconsole.log(Object.b === F.b) // true\n```\n看起来 F 和 Object 都是 Function 的实例？的确是这样的，所有的函数都是由 Function 的原型构造出来的，这么说 Function 是 JavaScript 的一个很基础的工具咯？但 JavaScript 不是万物皆对象吗，那 Object 和 Function 到底是什么关系呢？\n\n我们可以做以下测试：\n```js\nF instanceof Object // true\nF instanceof Function // true\nObject instanceof Function // true\nFunction instanceof Object // true\nObject == Function // false\n```\n完全懵了...\n\n为什么会出现这么怪异的结果，Object 和 Function 谁更底层一些？它们为什么会\"互为实例\"？\n\n通过对 JavaScript 各个概念出现先后顺序的分析，我得到了如下的一张图：\n\n![Js_Function_Object.png](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/Js_Function_Object.png)\n\n毫无疑问 JavaScript 是我学过的最糟糕的语言...\n\n首先解释一下这张图：\n1. 在 JavaScript 中，对象原型是最最基础的概念，通过对象原型得到了函数原型；\n1. 利用函数原型，可以构造出 Object()、Function() 函数，这个构造过程和其它函数的构造过程基本一致，但应该没有使用 new 运算符；\n1. 得到 Object 和 Function 后，便可以将对象原型和函数原型分别挂载到 Object 和 Function 的 prototype 上了；\n1. 利用装备上 prototype 的 Object 和 Function，便可以实现 new 运算。道生一，一生二，二生三，三生万物...\n\n结合该图和 instanceof 的判断规则，我们可以解释上面的结果：\n\n先附上 instanceof 判断规则的伪代码：\n```js\nfunction instance_of(L, R) { // L 表示左表达式，R 表示右表达式\n  if (isBasicType(L)) return false; // 如果是基础类型直接返回 false\n  var O = R.prototype; // 取 R 的显示原型\n  L = L.__proto__; // 取 L 的隐式原型\n  while (true) { \n    if (L === null) \n      return false; \n    if (O === L)\n      return true; \n    L = L.__proto__; \n  } \n}\n```\n结果解释：\n```js\nF instanceof Object // true, F.__proto__.__proto__ === '函数原型'.__proto__ === '对象原型' === Object.prototype\nF instanceof Function // true, F.__proto__ === '函数原型' === Function.prototype\nObject instanceof Function // true, Object.__proto__ === '函数原型' === Function.prototype\nFunction instanceof Object // true, Function.__proto__.__proto__ === '函数原型'.__proto__ === '对象原型' === Object.prototype\n```\n我们还可以从上图发现其它一些有趣的信息：\n```js\nFunction.prototype === Function.__proto__ // true\nObject.prototype === Object.__proto__.__proto__ // true\n```\n好了到此为止，我不该入门前端的...\n","tags":["JacaScript"],"categories":["技术相关"]},{"title":"桌面端软件实现 GitHub OAuth 第三方登录","url":"/blog/技术相关/桌面端软件实现-GitHub-OAuth-第三方登录/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/05.jpg\" width=\"65%\" height=\"65%\">\n\nOAuth (开放授权 Open Authorization) 是一个开放标准，允许用户授权第三方应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。\n但 GitHub OAuth 对桌面端的认证并没有直接的支持，本文提供了一种利用浏览器的缓存功能实现的针对桌面端 (移动端也适用) 的 GitHub OAuth 第三方登录方式，并提供了一个实例 (通过 Express.js 和 socket-io.js 搭建)。\n<!-- more -->\n\n## 思路和方法\n\n### 网页应用的授权步骤\n\nGitHub 提供了针对网站的第三方登录策略，主要步骤如下：\n1. 注册一个 OAuth App，得到 App 的 **Client ID** 和 **Client Secret**，具体请查看 [Creating an OAuth App](https://developer.github.com/apps/building-oauth-apps/creating-an-oauth-app/)\n1. 利用浏览器访问 `https://github.com/login/oauth/authorize?client_id={Client_ID}&scope=user:email` (将 **Client_ID** 替换为上一步得到的 **Client ID**，**scope** 参数是你希望得到的用户信息的内容，具体请查看 [understanding-scopes-for-oauth-apps](https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/))\n1. 当用户同意授权后，浏览器会重定向到我们到注册 App 时提供的回调地址，并在重定向链接中附带一个 **code** 参数。\n1. 后台利用 **code** 参数和第一步得到的 **Client ID** 和 **Client Secret** 访问 `https://github.com/login/oauth/access_token?client_id=${Client_ID}&client_secret=${Client_Secret}&code=${code}` 便可得到一个 **access_token**\n1. 利用得到的 **access_token** 结合 GitHub Api 便可访问该用户的信息\n\n### 桌面端软件授权的问题\n\n因为获取 **access_token** 需要 **code** 参数，而 **code** 参数是重定向链接的内容之一，只能在浏览器中获得。\n\n在网页应用中，后台通过 **code** 参数后可以得到 **access_token**，然后将 **access_token** 放到渲染好的网页中，发送到浏览器，浏览器将 **access_token** 保存到本地缓存，之后每次都访问网页资源都把本地缓存的 **access_token** 发送到后台，后台便能获得需要的用户信息，通过网页发送到浏览器。\n\n然而对于桌面端软件，软件可以自行打开浏览器访问认证链接，让用户确认是否授权，但得想个方法将后台获得的 **access_token** 发送到桌面端软件。其中最重要的是让后台知道不同的浏览器对应的桌面端软件是哪一个，解决这个问题之后，才能把用户在不同浏览器中确认授权后得到的 **access_token** 发送到对应的桌面端，桌面端把它存到软件的配置文件中。第二个问题是如何把 **access_token** 发送到桌面端。\n\n### 实现方法\n\n针对这两个问题，我分析了一下 [GitKraken](https://www.gitkraken.com/) 的登录策略，找到了他们利用 GitHub OAuth 登录的方法，这也是本篇文章介绍的重点内容。\n\n对于后台如何主动向客户端发送 **access_token** 的问题，解决的办法比较简单，让后台和桌面端软件建立 Socket 连接实现双向通信，每个 Socket 连接都有一个唯一标识，即 Socket id，当后台得到 **access_token** 后，利用 Socket id 将 **access_token** 发送到指定的桌面端即可。\n\n> 当然也可以采取轮询或 long pull 实现双向通信，但因为我们这里的后台相当于一个桥梁，用于连接客户端和 GitHub 的后台，所以对于每个客户端，都必须有一个唯一标识让后台知道每个 **access_token** 应该发给谁，Socket 连接本身提供了这个标识，无需我们额外产生，而这两种方法都需要自己产生一个唯一标识，相应的，后台也需要做一些多余的操作来储存这些标识，本文不采用这两种办法。\n\n解决了第二个问题，第一个问题中区分每个客户端的问题也就解决了，接下来要做的是实现把浏览器和客户端一一对应起来，现在浏览器的缓存技术(缓存客户端和服务器连接的 Socket id)终于可以派上用场了，步骤如下：\n\n![工作流](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/github-oauth-flow.png)\n\n1. 客户端主动建立 Socket 连接，得到 Socket id\n1. 将 Socket id 和其他必要的参数 (比如区分是否是移动端的参数) 嵌入到一个让用户确认是否继续认证的链接中，打开浏览器访问该链接，这个网页需要做的工作是在用户点击确认后，把 Socket id 和其他参数存到本地缓存中，然后访问认证链接\n(即 `https://github.com/login/oauth/authorize?client_id={Client_ID}&scope=user:email`)\n1. 在认证页面，用户确认授权后，网页会被重定向到我们在注册 App 时提供的回调地址，并附带 **code** 参数，回调地址产生的连接进入阻塞状态，等待服务器返回 **access_token**\n1. 回调地址对应的后台处理模块将 **code** 参数、**Client ID** 和 **Client Secret** 发送至 GitHub 后台\n(链接是：`https://github.com/login/oauth/access_token?client_id=${Client_ID}&client_secret=${Client_Secret}&code=${code}`)\n1. GitHub 后台验证 **code** 等参数的可用性，如果可用，GitHub 后台会将 **access_token** 返回给后台服务\n1. 后台得到 **access_token** 后，将它发送给浏览器 (第 3 步的阻塞状态结束)\n1. 浏览器得到 **access_token** 后，再将 **access_token**、缓存的 Socket id 和其他参数发送到后台，然后显示发送成功或失败的信息\n1. 后台相应的处理模块通过这些参数，将 **access_token** 发送到指定 Socket id 的桌面端\n\n## 实例\n\n### 平台和框架\n\n我用 Express.js 和 Socket-io.js 搭建了一个后台服务示例，GitHub 仓库地址：[whu-library-seat-ghauth](https://github.com/CS-Tao/whu-library-seat-ghauth)。\n\n> 桌面端仓库：[whu-library-seat](https://github.com/CS-Tao/whu-library-seat)，移动端仓库：[whu-library-seat-mobile](https://github.com/CS-Tao/whu-library-seat-mobile)。\n\n这里不再赘述代码上的细节，我将之前写的使用方法和截图记录在这里，供大家对比和参考。\n\n### 使用方法\n\n1. 点击软件下方的**钥匙**进入软件授权页面(第一次打开软件会默认进入本页面)\n\n  ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/1.png)\n\n1. 点击`GitHub Star 永久授权`按钮，软件会打开系统浏览器访问认证页面\n\n  ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/3.png)\n\n1. 点击`确定通过 GitHub 账号登录`，此时 GitHub 会让你确认是否授权(如果没有登录 GitHub，此时会进入登录页面)\n\n  ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/4.png)\n\n1. 点击`Authorize CS-Tao`即可成功登录\n\n  ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/5.png)\n\n1. 登录成功后返回软件，如果出现下面的弹窗，说明您还未对本仓库点星，请进行下一步\n\n  ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/5.1.png)\n\n1. 如果您还未给本仓库点星，请到指定仓库点星以供管理员了解软件使用情况。桌面端进入：[whu-library-seat](https://github.com/CS-Tao/whu-library-seat)，移动端进入：[whu-library-seat-mobile](https://github.com/CS-Tao/whu-library-seat-mobile)\n\n  - 桌面端点击右上角的`Star`按钮，按钮如下图所示：\n\n    ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/5.2.png)\n\n  - 移动端需要登录才会显示`Star`按钮，登录状态下直接点击即可，按钮如下图所示：\n  \n    ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/5.3.png)\n\n1. 点星后回到本软件，点击确定即可\n\n  ![图片加载失败](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/github/whu-library-seat/OAuth/6.png)\n","tags":["github-oauth"],"categories":["技术相关"]},{"title":"将 Vue 项目中的 Axios 替换为 cordova-plugin-advanced-http","url":"/blog/技术相关/将vue项目中的axios替换为cordova-plugin-advanced-http/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/cordova-vue.png\" width=\"20%\" height=\"20%\">\n\n对于 Vue 项目，官方建议的网络请求工具是 Axios，但在 Vue 项目和 cordova 集成的时候，我发现想要更改网络请求的 header 并不是一件很简单的事(比如修改 User-Agent)，cordova 对 Axios 发出的请求似乎还添加了一层封装。为了修改 User-Agent，不得已最后还是使用了 cordova 自己的 http 插件：[cordova-plugin-advanced-http](https://github.com/sfelipegp/cordova-plugin-advanced-http).<br/>不难发现 Axios 是使用的 Promise 实现异步网络请求，而 cordova-plugin-advanced-http 使用的却是函数回调。所以实现这个转换最关键问题其实是如何将函数回调替换为 Promise.\n<!-- more -->\n\n> 当然，能实现这个转换的前提是您在项目中是通过 `axios.create()` 创建了全局能访问到的实例，并且所有的网络请求都是调用这个实例实现的。也就是说本文记录的是如何将原来使用 `axios.create()` 创建的实例转换为 cordova-plugin-advanced-http 的网络请求函数。\n\n具体步骤如下：\n\n### 1. 添加 cordova-plugin-advanced-http 插件\n\n```bash\ncordova plugin add cordova-plugin-advanced-http\n```\n\n### 2. 添加 cordova 全局变量到 Vue 实例\n\n在 main.js 中添加下面的代码：\n```js\nVue.cordova = Vue.prototype.$cordova = window.cordova\n```\n\n### 3. 修改核心文件\n\n原文件内容：\n\n```js\nimport axios from 'axios'\n\n// 创建 Axios 实例\nconst request = axios.create({\n  baseURL: 'http://127.0.0.1:8888',\n  timeout: 5000,\n  withCredentials: true\n})\n\n// 发出之前的拦截器\nrequest.interceptors.request.use(config => {\n  // 修改请求头\n  config.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'\n  config.headers['User-Agent'] = null\n  return config\n}, error => {\n  Promise.reject(error)\n})\n\n// 接收到请求后的拦截器\nrequest.interceptors.response.use(response => response, error => {\n  // 打印错误\n  console.error(error.message)\n  return Promise.reject(error)\n})\n\nexport default request\n```\n\n修改之后的文件内容：\n\n```js\nimport Vue from 'vue'\n\n// 修改请求头\nVue.cordova.plugin.http.setHeader('*', 'Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8')\nVue.cordova.plugin.http.setHeader('*', 'User-Agent', '')\n\nconst baseURL = 'http://127.0.0.1:8888'\n\nconst request = (options) => {\n  // 将原 Axios 的配置项改为 cordova-plugin-advanced-http 的配置项\n  var sendOptions = {\n    method: options.method,\n    timeout: 5,\n    headers: options.headers ? options.headers : null,\n    params: options.params ? options.params : null,\n    data: options.data ? options.data : null\n  }\n  // cordova-plugin-advanced-http 的 headers 只支持字符串\n  for (var key in sendOptions.params) {\n    sendOptions.params[key] = options.params[key].toString()\n  }\n  var url = baseURL + options.url\n  return new Promise((resolve, reject) => {\n    Vue.cordova.plugin.http.sendRequest(url, sendOptions, (response) => {\n      response.data = JSON.parse(response.data)\n      resolve(response)\n    }, (response) => {\n      var error = {\n        message: response.error\n      }\n      // 打印错误\n      console.error(error.message)\n      reject(error)\n    })\n  })\n}\n\nexport default request\n```\n\n这样的修改可以使 request 的调用方法不变，即：\n\n```js\n// import request from 'file/path'\n\nrequest({\n  url: '/get/demo',\n  method: 'get',\n  headers: {\n    token: 'SJCU5VFS8C5SC2F'\n  },\n  params: {\n    username: account,\n    password: passwd\n  }\n}).then((response) => {\n  // 处理数据\n  console.log(JSON.stringify(response))\n}).catch((error) => {\n  // 处理错误\n  console.error(error.message)\n})\n```\n\n### 注意\n\n修改之后的文件只能在 cordava 的 `deviceready` 事件触发之后调用(否则 `Vue.$cordova 为 undefined`)，所以最好像按下面这样加载 Vue 实例(如果提前调用 `import App from './App'`，上面的代码会被提前加载)\n\n```js\n// 加载 Vue 实例\ndocument.addEventListener('deviceready', function () {\n  new Vue({\n    components: { App: require('./App').default },\n    router: require('./router').default,\n    store: require('./store').default,\n    template: '<App/>'\n  }).$mount('#app')\n}, false)\n```\n","tags":["Vue","cordova"],"categories":["技术相关"]},{"title":"Travis CI 自动化部署 Cordova 工程","url":"/blog/技术相关/Travis-CI-自动化部署-Cordova-工程/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/26.png\" width=\"45%\" height=\"45%\">\n\n前些时间心血来潮，开发了一款针对武汉大学图书馆预约系统的桌面端抢座软件(使用 Electron + Vue 搭建)，发布之后，有很多同学向我反映说想要 Android 版本的。\n\n虽然利用 Cordova/PhoneGap 将网页打包为 Android 安装包并不是一件很复杂的事，但在笔记本上安装 Android 的开发环境实在让人崩溃。\n\n但出于对用户需求的尊重，我还是开始了将网页打包为 Apk 的挖坑之旅，项目链接：[https://github.com/CS-Tao/whu-library-seat-mobile](https://github.com/CS-Tao/whu-library-seat-mobile)。\n\n本文用于记录在本项目中利用 Travis CI 持续集成和部署的配置代码。\n<!-- more -->\n\n### 以 node.js 为主环境的配置方法\n\n本方法的构建和部署耗时 580s 左右，构建日志：[https://travis-ci.com/CS-Tao/whu-library-seat-mobile/builds/88561677](https://travis-ci.com/CS-Tao/whu-library-seat-mobile/builds/88561677)\n\n```yml\nsudo: required\n\nlanguage: node_js\nnode_js: stable\n\ncache:\n  directories:\n    - node_modules\n    - cordova/node_modules\n\naddons:\n  apt:\n    sources:\n      - ubuntu-toolchain-r-test\n    packages:\n      - g++-4.8\n      - openjdk-7-jdk\n      - lib32stdc++6\n      - lib32z1\nenv:\n  CXX=g++-4.8\n\ninstall:\n  - yarn\n  - yarn --cwd cordova\n\nbefore_script:\n  # 添加 android 环境\n  - mkdir android-sdk\n  - wget -P android-sdk -q https://dl.google.com/android/android-sdk_r24.4.1-linux.tgz\n  - tar -xf ./android-sdk/android-sdk_r24.4.1-linux.tgz -C ./android-sdk\n  - echo y | ./android-sdk/android-sdk-linux/tools/android update sdk --no-ui --all --filter platform-tools\n  - echo y | ./android-sdk/android-sdk-linux/tools/android update sdk --no-ui --all --filter build-tools-26.0.2\n  - echo y | ./android-sdk/android-sdk-linux/tools/android update sdk --no-ui --all --filter android-27\n  - echo y | ./android-sdk/android-sdk-linux/tools/android update sdk --no-ui --all --filter extra-android-support\n  - echo y | ./android-sdk/android-sdk-linux/tools/android update sdk --no-ui --all --filter extra-android-m2repository\n  - echo y | ./android-sdk/android-sdk-linux/tools/android update sdk --no-ui --all --filter extra-google-m2repository\n  - export ANDROID_HOME=$PWD/android-sdk/android-sdk-linux\n  - export PATH=${PATH}:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools:$ANDROID_HOME/build-tools/26.0.2\n\nscript:\n  - yarn build\n  - cd cordova/\n  - npm install -g cordova\n  - cordova platform add android\n  - cordova prepare android\n  - cordova build android --release -- --keystore=\"release-key.keystore\" --alias=whu-library-seat-mobile --storePassword=${STORE_PASSWORD} --password=${PASSWORD}\n  - mv ./platforms/android/app/build/outputs/apk/release/app-release.apk whu-library-seat-mobile_${TRAVIS_TAG}.apk\n\ndeploy:\n  provider: releases\n  skip-cleanup: true\n  overwrite: true\n  api_key: $GH_TOKEN\n  file: \n    - \"whu-library-seat-mobile_${TRAVIS_TAG}.apk\"\n  on:\n    tags: true\n```\n源文件链接：[.travis.yml](https://github.com/CS-Tao/whu-library-seat-mobile/blob/3c67e5889c7fd1d3a05db23928cbfb0f17a20fc6/.travis.yml)\n\n### 以 android 为主环境的配置方法\n\n本方法的构建和部署耗时 450s 左右，构建日志：[https://travis-ci.com/CS-Tao/whu-library-seat-mobile/builds/89426551](https://travis-ci.com/CS-Tao/whu-library-seat-mobile/builds/89426551)\n\n```yml\nsudo: required\n\nlanguage: android\n\nandroid:\n  components:\n    - tools\n    - build-tools-26.0.2\n    - android-27\n    - extra-android-m2repository\n    - extra-android-support\n    - extra-google-m2repository\n  licenses:\n    - 'android-sdk-license.*'\n\ncache:\n  directories:\n    - node_modules\n    - cordova/node_modules\n\nbefore_install:\n  # 添加 node.js 环境\n  - curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -\n  - sudo apt-get install nodejs\n  - curl -o- -L https://yarnpkg.com/install.sh | bash\n  - source ~/.bashrc\n  - node -v && npm -v && yarn -v\n\ninstall:\n  - yarn\n  - yarn --cwd cordova\n\nscript:\n  - yarn build\n  - cd cordova/\n  - sudo npm install -g cordova\n  - cordova -v\n  - cordova platform add android\n  - cordova prepare android\n  - cordova build android --release -- --keystore=\"release-key.keystore\" --alias=whu-library-seat-mobile --storePassword=${STORE_PASSWORD} --password=${PASSWORD}\n  - mv ./platforms/android/app/build/outputs/apk/release/app-release.apk whu-library-seat-mobile_${TRAVIS_TAG}.apk\n  # - zipalign -v 4 ./platforms/android/app/build/outputs/apk/release/app-release.apk whu-library-seat-mobile_${TRAVIS_TAG}.apk\n\ndeploy:\n  provider: releases\n  skip-cleanup: true\n  overwrite: true\n  api_key: $GH_TOKEN\n  file: \n    - \"whu-library-seat-mobile_${TRAVIS_TAG}.apk\"\n  on:\n    tags: true\n```\n源文件链接：[.travis.yml](https://github.com/CS-Tao/whu-library-seat-mobile/blob/c55bf899c486b527ca621a21ed150b14019eb6f5/.travis.yml)\n\n### 说明\n\n> 请在 Travis CI 的网站中设置`$GH_TOKEN`环境变量并设置为不可见(默认便是不可见)，该环境变量是 GitHub 的`Personal access token`。\n\n> 代码中的`yarn build`命令用于将生产版本的网页放入 cordova 项目的`www`文件夹中。代码中的`${STORE_PASSWORD}`和`${PASSWORD}`环境变量为下面这条命令需要输入的两个密码，也应该添加到 Travis CI 的网站中，并设置为不可见。\n\n```bash\n# 在 cordova 项目的根目录中生成 release-key.keystore 文件\nkeytool -genkey -v -keystore release-key.keystore -alias whu-library-seat-mobile -keyalg RSA -keysize 2048 -validity 10000\n```\n","tags":["travis-ci","cordava","android"],"categories":["技术相关"]},{"title":"遥感院 2018 年夏令营成绩分析","url":"/blog/技术相关/遥感院-2018-年夏令营成绩分析/","content":"2018 年武汉大学遥感信息工程学院夏令营成绩的散点图矩阵，供日后有意参加我们院夏令营的同学们参考\n\n可视化的变量包括`机试成绩`、`面试成绩`、`背景评分`、`综合分数`\n> 优秀营员共 120 名(161 位同学参营)。机试成绩占 40%，面试成绩占 30%，背景评分占 30 %\n\n\n![2018 年武汉大学遥感信息工程学院夏令营成绩的散点图矩阵](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/25.png)\n","tags":["数据可视化"],"categories":["技术相关"]},{"title":"Git WorkFlow 小记","url":"/blog/软件开发/Git-WorkFlow-小记/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/22.png\" width=\"45%\" height=\"45%\">\n什么是 workflow？workflow 就是工作流，即工作的流程，是一个软件过程模型的体现。因为 git 不同分支的交叠，便构成了具有 git 特色的工作流。一个良好的工作流可以让我们的项目历史清晰明了，有利于更好的代码管理。利用 git 的分支管理功能，可以将软件生命周期的各个过程归并到各个分支上，实现软件开发过程中各个操作的隔离。\n在项目开发过程中，工作流是一个准则，由开发者自己定义，并自行遵守。本篇文章主要用于督促自己养成一个良好的开发习惯。\n<!-- more -->\n### 各个分支的使用\n\nGit workflow 分为五个分支，包括 `master`、`develop`、`release`、`hotfix` 和 `feature`，如下图：\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/21.png\" width=\"65%\" height=\"65%\">\n\n#### 长期分支\n\n在代码的中央仓库一直存在两个主要分支：`master` 和 `develop`。\n\n其他仓库(非中央仓库)的这两个分支应当始终和中央仓库保持一致，在每次向中央仓库的对应分支合并时，应当先确认中央仓库的对应分支(下面简称中央分支)没有新的提交，如果有新的提交，应当先把本分支的`基`设置为中央分支的最新提交，即使用 `rebase` 将中央分支与本分支合并，再将本分支合并(merge)到中央分支。\n- `master` 用于管理发布版本，每次 commit (其他分支向它合并形成的 merge commit)应当对应一个 Tag，也就是形成一个发布版。\n- `develop` 用于管理开发版本，所有的开发都会汇总到这个分支。\n\n#### 短期分支\n\n短期分支可以同时存在多个(当然命名不能重复)，每个分支使用完应当被删除掉，包括`release`、`hotfix` 和 `feature`。\n- `release` 用于在正式发布之前的预发布版本，在这个版本中的提交都应当是修复 Bug，不能在本分支上开发新的功能。本分支应当从 `develop` 检出，Bug 修复之后合并(merge)到 `develop` 和 `master`。\n- `feature` 用于新功能的开发，可以有多个。本分支应当从 `develop` 分支检出，功能开发完成后合并(merge)到 `develop`。\n> 在 `release` 和 `feature` 两个分支的开发过程中，如果 `develop` 分支有更新，可以选择不合并 `develop`，如果一定要合并。应当使用 `git rebase` 进行合并，即将 `feature` 的`基`和 `develop` 的最新提交保持一致。\n\n- `hotfix` 用于在版本发布之后的紧急 Bug 修复。本分支应当从 `master` 分支检出，在 Bug 修复之后直接合并(merge)到 `master` 和 `develop`。\n\n### 合并命令\n\n合并命令分为 merge 命令和 rebase 命令，在没有特别说明的情况下的合并命令一般指 merge 命令。\n\n#### Merge 命令\n\nMerge 命令可以让两个分支合并，但可能产生合并提交(merge commit)，在项目中一般都会使用 merge 命令进行分支的合并，但如果在某些情况下不想产生合并提交，则不应该使用这个命令。以将 `feature-1` 合并到 `develop` 为例：\n```bash\n# 切换到 develop 分支\ngit checkout develop\n# 策略合并 feature 分支\ngit merge --no-ff feature-1\n# 删除原分支\ngit branch -d feature-1\n# 推送 develop 分支到远程仓库\ngit push origin develop\n```\n\n#### Rebase 命令\n\nRebase 命令和它的字面意思一样，会改变该分支的`基`，它会将该分支的`基`变为另一个分支的最新的提交，`基`是一个分支在另一个分支中分叉后的的第一个提交。rebase 命令不会像 merge 命令那样产生合并提交，它会通过移动一个分支在另一个分支上分叉后的所有提交，形成一个完美的线性历史。例如，在 `feature-1` 的开发过程中需要将 `develop` 合并，但不希望合并提交的产生，便可以使用 rebase 命令：\n```bash\n# 如果不在 feature-1 分支，切换到 feature-1 分支\ngit checkout feature-1\n# 合并(rebase) develop 分支\ngit rebase develop\n```\n\n如果 `feature` 分支的提交太乱(比如有很多 *Fix bug*)，可以使用交互式 rebase 命令对 `feature` 分支的提交进行重构：\n```bash\n# 如果不在 feature-1 分支，切换到 feature-1 分支\ngit checkout feature-1\n# 交互式合并(rebase) develop 分支\ngit rebase -i develop\n```\n使用 `-i` 参数可以启动交互式的 rebase，它会打开一个文本编辑器，显示所有被移动的提交:\n```bash\npick 34b6aca 这是 feature 分支的第一次提交\npick 2bb57ac 修复第一次提交的 Bug\npick 233dc11 添加一个新功能\n```\n我们可以对这段代码进行编辑：\n```bash\npick 34b6aca 这是 feature 分支的第一次提交\nfixup 2bb57ac 修复第一次提交的 Bug\npick 233dc11 添加一个新功能\n```\n这样在最终形成的 `feature` 分支中便不会显示 `2bb57ac` 这次提交了(和之前的提交合并为一个新的提交)。当我们打开交互式 rebase 的时候，在注释里还可以看到其它功能的说明，利用这些功能我们可以随意地更改提交历史\n\n拉取并合并远程分支时使用 rebase 命令可以避免可能产生的合并提交：\n```bash\n# 采用 rebase 命令拉取并合并远程分支\ngit pull origin develop --rebase\n```\n因为 `git pull` 命令是 `git fetch` 命令和 `git merge` 命令的语法糖，加上 `--rebase` 参数会使合并过程采用 rebase 命令合并。\n\n#### 合并提交的产生\n\n合并提交(merge commit)可以将一个分支上的多个提交整合为一个，然后合并到另一个分支。如果两个分支没有出现分叉，这两个分支的合并是不会产生合并提交的。如果出现了分叉，它们的的合并(merge)一定会产生合并提交。\n\n### 合并准则\n\n#### 不能反向合并\n\n从上文我们可以看出，git workflow 中的五个分支是有一定服务关系的，其服务关系如下：\n- `feature` -> `develop`\n- `release` -> `develop` & `master`\n- `develop` -> `master`\n- `hotfix` -> `develop` & `master`\n\n在团队协作时，会有一定的服务关系，一般是非中心仓库的分支为中心仓库的分支服务。\n\n这里提到的**不能反向合并**即不能把被服务分支合并(merge)到服务分支(例如不能将 `develop` 合并到 `feature`)。当然，如果在开发过程中一定要反向合并，应当使用 rebase 合并。\n\n#### 采用策略合并\n\n在[Merge 命令](#Merge 命令)中我们使用了 `--no-ff` 参数，这会让 git 的合并(merge)操作不采用 `Fast-Forward` 的合并方式，而是采用策略合并，这样的合并可以保留分支间的合并历史，如下图：\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/20.png\" width=\"65%\" height=\"65%\">\n\n#### 在 GitHub 上 Review\n\nGitHub 提供的 Pull Request (简称“PR”)为我们提供了很好的代码合并的工具，开发者可以通过 PR 向自己的仓库或其他协助者的仓库发起合并请求。而且在这个合并请求中，我们可以对每次提交的具体内容和文件的更改情况进行 Review。例如我们可以在 GitHub 上执行 `release` 分支向 `master` 和 `develop` 分支的合并，并且在合并完成后添加发布版本到 GitHub 上。\n\n### 参考文章\n\n1. [简介我的 Git Work Flow](http://zhoulingyu.com/2017/05/08/Git-Work-Flow/)\n1. [Git 三大特色之 WorkFlow](https://blog.csdn.net/qq_32452623/article/details/78905181)\n","tags":["git","workflow"],"categories":["软件开发"]},{"title":"Vue 中手动触发 window.onresize() 函数","url":"/blog/技术相关/Vue中手动触发window-onresize函数/","content":"\n``` JavaScript\n// 添加 Vue 静态方法, 在全局通过调用 Vue.triggerResize() 触发\nVue.triggerResize = () => {\n  let e = document.createEvent('Event')\n  e.initEvent('resize', true, true)\n  window.dispatchEvent(e)\n}\n\n// 添加 Vue 实例方法, 在 Vue 实例中通过调用 this.$triggerResize() 触发\nVue.prototype.$triggerResize = Vue.triggerResize\n```\n","tags":["Vue"],"categories":["技术相关"]},{"title":"Docker 入门小记","url":"/blog/技术相关/Docker入门小记/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker.png\" width=\"45%\" height=\"45%\">\n\n原本是准备寒假在家学习 Docker 的，但很无奈的是，回到家的我完全不知道如何写下新年的第一段代码。<br/>说来也巧，回到学校后，由于某些不可抗力，搁置已久的消防项目又得开始了，原来负责服务器端 Docker 部署的某大神学长外出实习，重新部署 Docker 服务的任务就落在了我的头上(无奈.jpg)。<br/>我原本是不准备记录下这篇文章的，但是当我写完了 Dockerfile，向服务器部署的时候发现，这次部署可能需要 —— 三个小时？一个人在图书馆坐着，像看剧一样地看着命令终端不断输出完成进度，实在无聊，就想着把最近两天学到的知识记录一下吧。\n<!-- more -->\n\n### Docker 是什么？\n\nDocker 是 DotCloud 公司开发的基于 LXC(Linux Container，一种内核虚拟化技术)的高级容器引擎，go 语言编写，使用 Apache 2.0 开源协议，源代码托管在 Github 上。\n\n### Docker 原理\n\n我们可以发现近几年云计算非常流行，那么云计算是什么东西呢？\n>云计算是指通过互联网提供动态易扩展且经常是虚拟化的资源，被划分为IaaS(Infrastructure as a Service)、PaaS(Platform as a Service)、SaaS(Software as a Service)。\n\n但其中 PaaS 既不如 IaaS 那样灵活而自由，也不如 SaaS 那样可以直接推向消费者。有人说 PaaS 是未来的云计算，但是近几年 IaaS 和 SaaS 各自发展，反而是 PaaS 几乎裹足不前，虽然各种应用引擎层出不穷，但是没有什么人专门为 PaaS 开发应用。\n\n这个时候 Docker 的出现完美地解决了这个问题，Docker 很好地实现了 PaaS，如果把云计算比作货轮的话，Docker 就是放在货轮上的集装箱了。\n\n最开始我以为 Docker 和虚拟机差不多，因为都实现了虚拟化，而且都是可移植的。但是之后在各大技术交流平台上探索，我发现，这两个技术在本质上是有区别的，虚拟机直接面向了硬件层，而 Docker 则是面向操作系统层，它的出现和发展得益于 Linux 系统的 Namespace 机制和 CGroup 机制，这两个机制保证了 Docker 容器和外部环境的隔离，保障了 PaaS 的安全性。\n\n- Namespace 机制\n\nNamespace（命名空间）机制是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。Docker 便是通过 Linux 的 Namespaces 对不同的容器实现了这样的隔离。\n\n- CGroup 机制\n\n我们通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。\n\n如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups(简称 CGroups)就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。\n\n> 在 CGroup 中，所有的任务就是一个系统的一个进程，而 CGroup 就是一组按照某种标准划分的进程，在 CGroup 这种机制中，所有的资源控制都是以 CGroup 作为单位实现的，每一个进程都可以随时加入一个 CGroup 也可以随时退出一个 CGroup。<p align=\"right\">—— <a href=\"https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html\">CGroup 介绍、应用实例及原理描述</a></p>\n\n### 安装 Docker\n\n#### 设置存储库\n\n关于不同操作系统 Docker 的安装方法，[Docker 的官方文档](https://docs.docker.com/)写得很详细，因为 Docker 官方推荐使用 Ubuntu 部署 Docker(Ubuntu 系统本身就实现了Docker容器运行需要的 AUFS 机制)，所以这里只记录一下 Ubuntu 16.04 系统下 Docker CE 的安装。\n\n- 更新apt包索引\n    ```bash\n    $ sudo apt-get update\n    ```\n- 安装软件包，用于允许 apt 通过 HTTPS 访问 Docker 安装源\n    ```bash\n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common\n    ```\n- 添加 Docker 的官方 GPG 密钥：\n    ```bash\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    ```\n    确认一下您已经获取到了指纹：\n    ```bash\n    $ sudo apt-key fingerprint 0EBFCD88\n\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    ```\n- 添加储存库：\n    ```bash\n    $ sudo add-apt-repository \\\n    \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n    $(lsb_release -cs) \\\n    stable\"\n    ```\n\n#### 安装 Docker CE\n\n- 更新 apt 包索引\n    ```bash\n    $ sudo apt-get update\n    ```\n- 安装Docker CE\n    ```bash\n    $ sudo apt-get install docker-ce\n    ```\n\n### Docker 命令记录\n\n因为 Docker 的运行绑定了`/var/run/docker.sock`文件，用于 docker 的守护进程(Docker daemon)和容器进程之间通信，而该文件的访问权限为 660，必须使用 sudo 命令才有该文件的执行权限。\n\n#### 容器的生命周期管理\n\n- run：Run a command in a new container\n- start：Start one or more stopped containers\n- stop：Stop one or more running containers\n- restart：Restart one or more containers\n- kill：Kill one or more running containers\n- rm：Remove one or more containers\n- pause：Pause all processes within one or more containers\n- unpause：Unpause all processes within one or more containers\n- create：Create a new container\n- exec：Run a command in a running container\n\n#### 容器操作\n\n- ps：List containers\n- inspect：Return low-level information on Docker objects\n- top：Display the running processes of a container\n- attach：Attach local standard input, output, and error streams to a running container\n- events：Get real time events from the server\n- logs：Fetch the logs of a container\n- wait：Block until one or more containers stop, then print their exit codes\n- export：Export a container's filesystem as a tar archive\n- port：List port mappings or a specific mapping for the container\n\n#### 容器 rootfs 命令\n\n- commit：Create a new image from a container's changes\n- cp：Copy files/folders between a container and the local filesystem\n- diff：Inspect changes to files or directories on a container's filesystem\n\n#### 镜像仓库操作\n\n- login：Log in to a Docker registry\n- logout：Log out from a Docker registry\n- pull：Pull an image or a repository from a registry\n- push：Push an image or a repository to a registry\n- search：Search the Docker Hub for images\n\n#### 本地镜像管理\n\n- images：List images\n- rmi：Remove one or more images\n- tag：Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE\n- build：Build an image from a Dockerfile\n- history：Show the history of an image\n- save：Save one or more images to a tar archive (streamed to STDOUT by default)\n- import：Import the contents from a tarball to create a filesystem image\n\n#### Docker 信息\n\n- info：Display system-wide information\n- version：Show the Docker version information\n\n### Dockerfile、Daemon 进程、镜像、容器之间的关系\n\n前两天看了本书《Docker 全攻略》，里面提到 Docker 的出现统一了三界（开发、测试、生产）。Dockerfile 面向开发，Docker 镜像可以直接交付给我们的甲方，Docker容器面向部署和运维。Daemon 进程是 Docker 运行的主进程，负责和容器间的通信。\n\n我们使用 Docker，最后会得到一个运行状态的容器，简单来说，使用Docker大概的步骤是：编写 Dockerfile 生成镜像，启动镜像，然后可以得到容器。\n\n也就是说，Dockerfile 是生成镜像和容器的原材料，它会被 Docker 解释器解释，生成指定的镜像，镜像是静态的文件，启动镜像便能得到运行的容器，镜像和容器之间的关系可以理解为一个已经关机的电脑和一个开机状态的电脑的关系，顺便我们可以把 Dockerfile 理解为给电脑装系统时的用到的 ISO 镜像。\n\n接下来，本文会重点介绍一下镜像和容器之间的关系，参考自我前两天在网上一篇文章，文章的链接已附在文末。\n\n#### Docker 容器和镜像的关系\n\n容器和镜像的大概关系可以参考下图：\n\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/container.png\" width=\"85%\" height=\"85%\">\n如图，镜像是分层的文件，每一层都是只读的，其分层的方式类似于 git 的版本控制方式，除了最底层，每一层都会有它的父层，每一层都记录了和上一层的差异(diff)，而容器则是在顶层运行的一个可读写层。\n\n现在，我们可以通过特定的命令来了解一下它们之间的关系。\n\n- `sudo docker create <image-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/create.jpg\" width=\"85%\" height=\"85%\">\n`docker create`命令为指定的镜像(image)添加了一个可读写层，构成了一个新的容器，但这个容器并没有运行。\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/create1.png\" width=\"85%\" height=\"85%\">\n\n- `sudo docker start <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/start.jpg\" width=\"85%\" height=\"85%\">\n`Docker start`命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。\n\n- `sudo docker run <image-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/run.jpg\" width=\"85%\" height=\"85%\">\n我们可以看到`docker start`命令和`docker run`命令都生成了容器，它们有什么区别呢？\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/start1.png\" width=\"85%\" height=\"85%\">\n从图片可以看出，`docker run`命令先是利用镜像创建了一个容器，然后运行这个容器。\n\n- `sudo docker ps`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/ps.jpg\" width=\"85%\" height=\"85%\">\n`docker ps`命令会列出所有运行中的容器。这隐藏了非运行态容器的存在，如果想要找出这些容器，我们需要使用下面这个命令。\n\n- `sudo docker ps –a`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/psa.jpg\" width=\"85%\" height=\"85%\">\n`docker ps –a`命令会列出所有的容器，不管是运行的，还是停止的。\n\n- `sudo docker images`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/images.jpg\" width=\"85%\" height=\"85%\">\n`docker images`命令会列出了所有顶层(top-level)镜像。\n\n- `sudo docker images –a`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/imagesa.jpg\" width=\"85%\" height=\"85%\">\n`docker images –a`命令列出了所有的镜像，也可以说是列出了所有的可读层。如果你想要查看某一个 image-id 下的所有层，可以使用`docker history`来查看。\n\n- `sudo docker stop <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/stop.jpg\" width=\"85%\" height=\"85%\">\n`docker stop`命令会向运行中的容器发送一个 SIGTERM 的信号，然后停止所有的进程。\n\n- `sudo docker kill <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/kill.jpg\" width=\"85%\" height=\"85%\">\n`docker kill`命令向所有运行在容器中的进程发送了一个不友好的 SIGKILL 信号。\n\n- `sudo docker pause <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/pause.jpg\" width=\"85%\" height=\"85%\">\n`docker stop`和`docker kill`命令会发送 UNIX 的信号给运行中的进程，`docker pause`命令则不一样，它利用了 cgroups 的特性将运行中的进程空间暂停。但是这种方式的不足之处在于发送一个 SIGTSTP 信号对于进程来说不够简单易懂，以至于不能够让所有进程暂停。\n\n- `sudo docker rm <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/rm.jpg\" width=\"85%\" height=\"85%\">\n`docker rm`命令会移除构成容器的可读写层。注意，这个命令只能对非运行态容器执行。\n\n- `sudo docker rmi <image-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/rmi.jpg\" width=\"85%\" height=\"85%\">\n`docker rmi`命令会移除构成镜像的一个只读层。你只能够使用`docker rmi`来移除最顶层(top level layer)(也可以说是镜像)，你也可以使用 -f 参数来强制删除中间的只读层。\n\n- `sudo docker commit <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/commit.jpg\" width=\"85%\" height=\"85%\">\n`docker commit`命令将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/commit1.png\" width=\"85%\" height=\"85%\">\n\n- `sudo docker build`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/build.jpg\" width=\"85%\" height=\"85%\">\n`docker build`命令它会反复的执行多个命令，如下图\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/build1.png\" width=\"85%\" height=\"85%\">\n`docker build`命令根据 Dockerfile 文件中的 FROM 指令获取到镜像，然后重复地 1) `run(create和start)`、2) `修改`、3) `commit`。在循环中的每一步都会生成一个新的层，因此许多新的层会被创建。\n\n- `sudo docker exec <running-container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/exec.jpg\" width=\"85%\" height=\"85%\">\n`docker exec`命令会在运行中的容器执行一个新进程。\n\n- `sudo docker inspect <container-id> or <image-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/inspect.jpg\" width=\"85%\" height=\"85%\">\n`docker inspect`命令会提取出容器或者镜像最顶层的元数据。\n\n- `sudo docker save <image-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/save.jpg\" width=\"85%\" height=\"85%\">\n`docker save`命令会创建一个镜像的压缩文件，这个文件能够在另外一个主机的 Docker 上使用。和 export 命令不同，这个命令为每一个层都保存了它们的元数据。这个命令只能对镜像生效。\n\n- `sudo docker export <container-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/export.jpg\" width=\"85%\" height=\"85%\">\n`docker export`命令创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到的内容\n\n- `sudo docker history <image-id>`\n<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/docker/history.jpg\" width=\"85%\" height=\"85%\">\n`docker history`命令递归地输出指定镜像的历史镜像。\n\n### 参考文章\n\n- [官方文档](https://docs.docker.com/)\n- [Docker 核心技术与实现原理](http://dockone.io/article/2941)\n- [CGroup 介绍、应用实例及原理描述](https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html)\n- [10 张图带你深入理解 Docker 容器和镜像](http://dockone.io/article/783)\n- [Dockerfile、Docker 镜像和 Docker 容器的关系](http://blog.csdn.net/zhousenshan/article/details/51501734)\n- [菜鸟教程 - Docker 命令大全](http://www.runoob.com/docker/docker-command-manual.html)\n- [为什么 Docker 如此受欢迎？](http://cloud.51cto.com/art/201406/442131.htm)\n","tags":["docker"],"categories":["技术相关"]},{"title":"远程git仓库的建立和配置","url":"/blog/技术相关/远程git仓库的建立和配置/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/gi2.png\" width=\"20%\" height=\"20%\">\n\n本文主要介绍如何建立远程 git 仓库以及如何在 gitweb 页面中显示仓库的描述信息，以 Ubuntu 16.04 LTS 操作系统为例。\n<!-- more -->\n\n# 安装并配置 gitweb\n\n参考[基于 Apache 服务器的 gitweb 安装和配置](http://blog.cs-tao.cc/2017/10/19/gitweb%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/)\n\n# 新建文件夹\n\n为了能在 gitweb 上查看仓库的信息，建议在 gitweb 的仓库根目录下新建文件夹（仓库根目录在 gitweb 的配置文件\"/etc/gitweb.conf\"中由\"$projectroot\"变量指定）\n\n~~~bash\nmkdir Test.git\n~~~\n\ngit 远程库目录建议带上 .git 后缀。\n\n# 更改文件夹权限并切换到用于远程 ssh 连接的用户\n\n因为我们用于连接私有 git 仓库的方法是 ssh 远程连接，我们以有远程 ssh 登录权限的用户 'CSTao' 为例。\n\n~~~bash\nchown -R CSTao:CSTao Test.git\nsu CSTao\n~~~\n\n> 注意：本步骤和第一步的顺序可以交换，那么便可以不使用 chown 命令更改文件夹权限，只切换用户即可。这样做的原因是我新建的文件夹所在目录的权限不属于用户 CSTao，以 CSTao 用户新建文件夹会出现权限不足的警告。\n\n# 建立仓库\n\n ~~~bash\n cd Test.git\n git init --bare\n ~~~\n 和建立本地仓库的命令不一样的是，建立远程仓库其实建立了一个裸仓库，也就是不含文件信息，只有 git 的提交记录。\n\n# 配置描述信息\n\n## 修改描述文件\n\n ~~~bash\n vim description\n ~~~\n 写入描述信息即可\n\n## 修改配置文件\n\n ~~~bash\n vim config\n ~~~\n 在原有内容后添加\n ~~~bash\n[gitweb]\n        owner = CSTao <whucstao@qq.com>\n        URL = ssh://CSTao@39.108.171.209:22/home/git/repositories/Test.git\n ~~~\n 通过owner指定gitweb中owner的显示内容，通过URL指定gitweb中URL的显示内容，基本格式为\"ssh://[ssh登录的用户名]@[host:ssh端口][远程主机中的仓库目录]\"\n\n# 将远程裸仓库克隆到本地\n\n 在本地计算机的特定文件夹中执行：\n ~~~bash\n git clone ssh://CSTao@39.108.171.209:22/home/git/repositories/Test.git\n ~~~\n\n# 添加文件、提交更改、推送到远程\n\n这部分内容为 git 的基本操作，不再赘述\n","tags":["git","gitweb"],"categories":["技术相关"]},{"title":"gitweb 安装和配置","url":"/blog/技术相关/gitweb安装和配置/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/gitweb.png\" width=\"20%\" height=\"20%\">\n\nApache 环境下的 gitweb 的安装和配置。\n<!-- more -->\n\n# gitweb 安装和配置（在别人的基础上做了一些添加和修改）\n\n[参考文章](http://blog.csdn.net/qq_25667339/article/details/53083968)\n\n## 安装 gitweb 和 Apache\n\n```bash\nsudo apt-get install gitweb apache2\n```\n\n## 修改 /etc/gitweb.conf\n\n```bash\nvim /etc/gitweb.conf\n```\n\n内容如下：\n\n```bash\n$projectroot = \"/home/git/repositories\";\n\n$git_temp = \"/tmp\";\n\n$projects_list = $projectroot;\n\n@stylesheets = (\"../gitweb/static/gitweb.css\");\n\n$javascript = \"../gitweb/static/gitweb.js\";\n\n$logo = \"../gitweb/static/git-logo.png\";\n\n$favicon = \"../gitweb/static/git-favicon.png\";\n\n@diff_opts = ();\n```\n\n保存退出\n\n## 修改 /etc/apache2/conf-available/gitweb.conf\n\n```bash\nvim /etc/apache2/conf-available/gitweb.conf\n```\n\n内容如下：\n\n```xml\nAlias /gitweb /usr/share/gitweb\n<Directory /usr/share/gitweb>\n    Options +FollowSymLinks +ExecCGI\n    AddHandler cgi-script .cgi\n    AuthType Basic\n    AuthName \"Restricted Content\"\n    AuthUserFile /home/git/.htpasswd\n    Require valid-user\n</Directory>\n```\n\n保存退出\n\n`注意：`\"AuthUserFile\"是认证文件位置，用如下命令生成认证文件并添加一个访问用户：\n\n```bash\nhtpasswd -c 认证文件位置 用户名\n```\n\n然后根据提示输入密码即可。\n\n## 使cgi生效\n\n```bash\nsudo a2enmod cgi\nsudo service apache2 restart\n```\n\n## 访问gitweb\n\n如果搭建在本地，访问[http://localhost/gitweb](http://localhost/gitweb)并登录就可看到 gitweb 设置的 git 库根目录下的所有项目信息。\n\n但此时访问[http://localhost/cgi-bin/gitweb.cgi](localhost/cgi-bin/gitweb.cgi)不用登录也能访问到项目信息。我直接删除了\"/usr/lib/cgi-bin/\"文件夹中与 gitweb 相关的文件。其他人便不能通过该路径访问。\n\n## 配置布局\n\n可以使用别人已经写好的布局和图标，详见[github](https://github.com/kogakure/gitweb-theme)\n\n# 注意事项\n\n- 需要将\"/usr/share/gitweb\"文件夹下的文件和文件夹设置正确的权限，<其他用户>必须有读取文件权限和执行文件权限。缺少读文件的权限服务器会返回\"Internal Server Error(500)\"错误，缺少执行文件的权限服务器会返回\"Forbidden(403)\"错误。读取文件权限为4，执行文件权限为1，也就是说<其他用户>的权限至少为'5'。如下，这里设置的'755'权限的最后一个'5'对应<其他用户>的权限。\n\n    ~~~bash\n    cd /usr/share/gitweb/\n    sudo chmod -R 755 .\n    ~~~\n\n- 旧版本 Apache 的 /etc/apache2/conf.d/gitweb 和新版本的 /etc/apache2/conf-available/gitweb 的是同一个目录。\n\n# 配置文件备忘\n\n## 主配置文件\n\n- 文件位置：\"/etc/gitweb.conf\"\n- 文件功能：设置项目集根目录、临时文件目录、布局文件位置及资源文件位置等。\n\n## Apache中gitweb的配置\n\n- 文件位置：\"/etc/apache2/conf-available/gitweb.conf\"\n- 文件功能：指定 CGI 文件位置、认证文件位置等。\n- 主要内容：\n\n```xml\n<IfDefine ENABLE_GITWEB>\n    Alias /gitweb /usr/share/gitweb\n    <Directory /usr/share/gitweb>\n        Options +FollowSymLinks +ExecCGI\n        AddHandler cgi-script .cgi\n        AuthType Basic\n        AuthName \"Restricted Content\"\n        AuthUserFile /home/git/.htpasswd\n        Require valid-user\n    </Directory>\n</IfDefine>\n```\n","tags":["gitweb","Apache"],"categories":["技术相关"]},{"title":"解决C#发送电子邮件失败的问题","url":"/blog/技术相关/解决C-发送电子邮件失败的问题/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/mail.png\" width=\"20%\" height=\"20%\">\n\n本文记录了在 C# 环境下，如何利用 SMTP 邮箱服务发送邮件，以 QQ 邮箱为例\n<!-- more -->\n\n# 实现过程\n\n- 配置 App.Config 文件\n    - 在项目中添加`System.Configuration`程序集的引用\n    - 在 App.Config 文件中添加键值，如下（只需要关注 appSettings 标签内的内容）\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <configSections>\n    <section name=\"entityFramework\" type=\"System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=*************\" requirePermission=\"false\" />\n  </configSections>\n  <startup>\n    <supportedRuntime version=\"v4.0\" sku=\".NETFramework,Version=v4.5.2\" />\n  </startup>\n  <appSettings>\n  <!--邮箱-->\n    <add key=\"MANAGER_MAIL_NUM\" value=\"123456789@qq.com\" />\n    <!--邮箱密码-->\n    <add key=\"MANAGER_MAIL_PASSWORD\" value=\"邮箱密码。QQ邮箱需要许可码\" />\n    <!--邮件显示名-->\n    <add key=\"MANAGER_MAIL_NAME\" value=\"发送邮件使用的用户名\" />\n    <!--QQ邮箱对应的SMTP服务器-->\n    <add key=\"SmtpClient_HOST\" value=\"smtp.qq.com\"/>\n  </appSettings>\n</configuration>\n```\n\n- EmailHelper.cs 文件内容\n\n```C#\nusing System;\nusing System.Text;\nusing System.Net.Mail;\nusing static System.Configuration.ConfigurationManager;\n\nnamespace View_Spot_of_City.UIControls.Helper\n{\n    public static class EmailHelper\n    {\n        public static bool SendEmail(string mail, string title, string content)\n        {\n            MailMessage message = new MailMessage();\n            {\n                message.To.Add(mail);\n                message.From = new MailAddress(AppSettings[\"MANAGER_MAIL_NUM\"], AppSettings[\"MANAGER_MAIL_NAME\"], Encoding.UTF8);\n                message.Subject =title;\n                message.SubjectEncoding = Encoding.UTF8;\n                message.Body = content;\n                message.BodyEncoding = Encoding.UTF8;\n                message.IsBodyHtml = false;\n                message.Priority = MailPriority.Normal;\n            }\n\n            SmtpClient smtp = new SmtpClient();\n            {\n                smtp.Host = AppSettings[\"SmtpClient_HOST\"];\n                smtp.EnableSsl = true;\n                smtp.UseDefaultCredentials = false;\n                smtp.Credentials = new System.Net.NetworkCredential(AppSettings[\"MANAGER_MAIL_NUM\"], AppSettings[\"MANAGER_MAIL_PASSWORD\"]);\n            }\n            object userState = message;\n            try\n            {\n                smtp.SendAsync(message, userState);\n                return true;\n            }\n            catch(Exception ex)\n            {\n                Console.Write(ex.Message);\n                return false;\n            }\n        }\n    }\n}\n```\n\n# 注意\n\n若使用 QQ 邮箱，输入密码为许可码，需要在 QQ 邮箱中打开 SMTP 服务\n\n- 打开 QQ 邮箱网页版\n- 点击左上角\"设置\"，并在导航栏中点击账户标签\n- 开启 SMTP 服务并获得许可码\n    ![开启 SMTP 服务](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/WpfSendMail.png)\n","tags":["C#"],"categories":["技术相关"]},{"title":"Js利用百度地图API进行坐标转换","url":"/blog/技术相关/Js利用百度API进行坐标转换/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/baidu-map.png\" width=\"20%\" height=\"20%\">\n\n在 JavaScript 中利用百度地图API对地理坐标系和投影坐标系(墨卡托)进行互转\n<!-- more -->\n\n# 导入js文件\n\n在html文件中添加\n\n```javascript\n<script src=\"http://api.map.baidu.com/api?v=1.2\"></script>\n```\n\n# 地理坐标转为平面坐标\n\n```javascript\nvar projection = new BMap.MercatorProjection();\nvar mercatorPoint = projection.lngLatToPoint(new BMap.Point(114.3908, 30.4879));\nalert(\"x = \" + mercatorPoint.x + \", y = \" + mercatorPoint.y);\n```\n\n# 平面坐标转为地理坐标\n\n```javascript\nvar projection = new BMap.MercatorProjection();\nvar lngLat = projection.pointToLngLat(new BMap.Pixel(12734064.16, 3544542.8));\nalert(\"lng = \" + lngLat.lng + \", lat = \" + lngLat.lat);\n```\n","tags":["JacaScript"],"categories":["技术相关"]},{"title":"GMap.net for WPF 使用心得","url":"/blog/软件开发/GMap.net-for-WPF-使用心得/","content":"<img src=\"https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/others/gmap.png\" width=\"20%\" height=\"20%\">\n\n本文记录了利用 GMap.net for WPF 绘制点线面的方式和在项目中遇到的对未指定长宽的要素与其他要素间相对定位的方式\n<!-- more -->\n\n## GMap.net概述\n\n[GMap.net](https://greatmaps.codeplex.com/ \"进入GMap.NET的项目地址\")是一个强大、免费、跨平台、开源的 .NET 控件，它在 WinForm 和 WPF 环境中能够通过 Google, Yahoo!, Bing, OpenStreetMap, ArcGIS, Pergo, SigPac 等实现寻找路径、地理编码以及地图展示功能，并支持缓存和运行在 Mobile 环境中。<br>GMap.NET 是一个开源的GEO地图定位和跟踪程序。就像谷歌地图、雅虎地图一样，可以自动计算两地的距离，定位经纬度，与 Google 地图不同的是，该项目是建立在 WinForm 框架或 WPF 框架基础上的。可以对地图放大缩小，进行城市标记等。\n\n## GMap.net for WPF 绘制要素\n\n* 不同于 Winform 版本，WPF 版本没有图层的概念，但用于显示要素的对象 GMapMarker 提供了 Zindex 属性，该属性值大的会遮盖属性值小的。所以大家可以利用 Zindex 对地理要素建立逻辑上的图层关联。\n\n* WinForm版本绘图可以直接在显示对象上设置图形的属性，如：\n    ```C#\n    GMapPolygon polygon = new GMapPolygon(pointList, \"Polygon\")\n    {\n        IsHitTestVisible = true;\n        Fill = new SolidBrush(Color.FromArgb(50, Color.Red));\n        Stroke = new Pen(Color.Blue, 2);\n    }\n    overlay.Polygons.Add(polygon);\n    ```\n    对于wpf版本的点对象，可以直接指定显示用户控件，如：<br>\n    ```C#\n    GMapMarker marker = new GMapMarker(pointLatLng);\n    {\n        MyUserControl myUserControl = new MyUserControl()\n        marker.Shape = myUserControl;\n        marker.ZIndex = (int)LayerIndex.Point;\n        marker.Offset = new Point(-myUserControl.ActualWidth / 2, -myUserControl.ActualHeight / 2);\n    }\n    mapControl.Markers.Add(marker);\n    ```\n    其中 MyUserControl 可以重载自 UserControl，并自定义显示内容。LayerIndex 为自定义的枚举类型。mapControl 重载自GMapControl。\n    但是wpf版本的线的属性设置需要重载 GMapControl 的 CreateRoutePath 方法，面的属性设置需要重载 CreatePolygonPath 方法。为了不影响原函数的内容，我们可以参考 GMapControl 的源代码[*GMapControl.cs*](https://greatmaps.codeplex.com/SourceControl/latest#GMap.NET.WindowsPresentation/GMap.NET.WindowsPresentation/GMapControl.cs \"查看源码文件\")文件。重载 CreateRoutePath 方法和 CreatePolygonPath 后的内容如下，只做了少量修改：\n\n    ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreateRoutePath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n\n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], false, false);\n\n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n\n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n\n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n\n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n\n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = lineBrush;\n            myPath.StrokeThickness = lineWidth;\n            myPath.StrokeLineJoin = PenLineJoin.Round;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Round;\n\n            myPath.Opacity = lineOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中 lineBrush、lineWidth、lineOpacity 为重载 GMapControl 时新添的公共字段。\n\n    ```C#\n    /// <summary>\n    /// creates path from list of points, for performance set addBlurEffect to false\n    /// </summary>\n    /// <param name=\"pl\"></param>\n    /// <returns></returns>\n    public override Path CreatePolygonPath(List<Point> localPath, bool addBlurEffect)\n    {\n        // Create a StreamGeometry to use to specify myPath.\n        StreamGeometry geometry = new StreamGeometry();\n\n        using (StreamGeometryContext ctx = geometry.Open())\n        {\n            ctx.BeginFigure(localPath[0], true, true);\n\n            // Draw a line to the next specified point.\n            ctx.PolyLineTo(localPath, true, true);\n        }\n\n        // Freeze the geometry (make it unmodifiable)\n        // for additional performance benefits.\n        geometry.Freeze();\n\n        // Create a path to draw a geometry with.\n        Path myPath = new Path();\n        {\n            // Specify the shape of the Path using the StreamGeometry.\n            myPath.Data = geometry;\n\n            if (addBlurEffect)\n            {\n                BlurEffect ef = new BlurEffect();\n                {\n                    ef.KernelType = KernelType.Gaussian;\n                    ef.Radius = 0.0;\n                    ef.RenderingBias = RenderingBias.Performance;\n                }\n\n                myPath.Effect = ef;\n            }\n\n            myPath.Stroke = polygonStrokeBrush;\n            myPath.StrokeThickness = polygonThickness;\n            myPath.StrokeLineJoin = PenLineJoin.Miter;\n            myPath.StrokeStartLineCap = PenLineCap.Triangle;\n            myPath.StrokeEndLineCap = PenLineCap.Square;\n\n            myPath.Fill = polygonFillBush;\n\n            myPath.Opacity = polygonOpacity;\n            myPath.IsHitTestVisible = false;\n        }\n        return myPath;\n    }\n    ```\n    `注意:`代码中 polygonStrokeBrush、polygonThickness、polygonFillBush、polygonOpacity 为重载 GMapControl 时新添的公共字段。\n* wpf 版本只能绘制 Point、PolyLine、Polygon 三种图形，绘制圆则需要借助多边形的绘制。示例如下：\n    ```C#\n    public void DrawCircle(PointLatLng center, double R)\n    {\n        double cartesianCenterX = double.MaxValue;\n        double cartesianCenterY = double.MaxValue;\n        double cartesianCenterZ = double.MaxValue;\n\n        mapControl.MapProvider.Projection.FromGeodeticToCartesian(center.Lat, center.Lng, 0, out cartesianCenterX, out cartesianCenterY, out cartesianCenterZ);// 将圆心投影到笛卡尔坐标系\n\n        int pointCount = 200;// 用于拟合圆的多边形顶点个数\n\n        List<PointLatLng> polygonPointList = new List<PointLatLng>(pointCount);// 用于存放多边形顶点\n\n        double interval = 2 * Math.PI / pointCount;\n        for (double degree = 0; degree < 2 * Math.PI; degree += interval)\n        {\n            double tempX = cartesianCenterX + R * Math.Cos(degree);\n            double tempY = cartesianCenterY + R * Math.Sin(degree);\n            double tempLng = double.MaxValue;\n            double tempLat = double.MaxValue;\n            mapControl.MapProvider.Projection.FromCartesianTGeodetic(tempX, tempY, cartesianCenterZ, out tempLat, out tempLng);// 投影到WGS84坐标系\n            polygonPointList.Add(new PointLatLng(tempLat, tempLng));\n        }\n\n        GMapPolygon circle = new GMapPolygon(polygonPointList);\n        {\n            circle.ZIndex = (int)LayerIndex.Polygon;\n        }\n        mapControl.Markers.Add(circle);// 添加到地图\n    }\n    ```\n    效果如下：\n    ![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/GMap-Wpf-Draw-Circle.png)<br>\n    因为投影问题，说好的圆变为了椭圆，如果想生成正圆，可以在程序中使用一些 WebAPI 服务替换 GMap 的投影服务，我们项目使用的是搭建在自己服务器上的的 GeoServer 服务。效果如下：\n    ![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/FGIS-Damage-Circle.png)<br>\n\n## 未指定长宽的要素与其他要素间相对定位的方式\n\n在使用 GMap 添加要素的时候，遇到需要对要素添加 Tooltip，但不能指定 Tooltip 的长宽，且该要素与 Tooltip 需要水平中心对其，试过很多办法都不能成功，因为 wpf 控件的 ActualWidth 和 ActualHeight 属性必须加载过一次才能有正确的属性值，也就是说如果根据长宽计算 GMapMarker 的偏移量，Tolltip 在第一次显示的时候无法正确定位，经过探索，最终利用 wpf 控件的 SizeChanged 响应函数实现了该效果。效果如下：<br>\n![软件截屏](https://raw.githubusercontent.com/CS-Tao/github-content/master/contents/blog/image/GMap-Tooltip.png)\n\n```C#\npublic void AddIconWithTooltip(PointLatLng pll, Uri iconUri, string tooltip)\n{\n    Guid id = Guid.NewGuid();\n\n    // 添加tooltip显示窗口\n    GMapMarker tooltipViewer = new GMapMarker(pll);\n    {\n        tooltipViewer.ZIndex = (int)LayerIndex.Point;\n        tooltipViewer.Tag = id;\n        TooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n        tooltipViewer.Shape = content;\n        tooltipViewer.Shape.Visibility = Visibility.Hidden;\n    }\n    mapControl.Markers.Add(tooltipViewer);\n\n    UIElement shape = new MyIcon(new BitmapImage(iconUri), tooltipViewer);// 构造函数：MyIcon(ImageSource image, GMapMarker iconTooltipViewer, double width = 22, double height = 22, bool showTipAlways = false)\n\n    GMapMarker iconMarker = new GMapMarker(pll);\n    {\n        iconMarker.ZIndex = (int)layerIndex;\n        iconMarker.Offset = new Point(-11, -11);\n        iconMarker.Tag = id;\n        iconMarker.Shape = shape;\n    }\n    mapControl.Markers.Add(iconMarker);\n}\n```\n\n`注意：`代码中id的作用是用于 GMapMarker 间的逻辑关联，方便同时从 MapControl 中移除。<br>\n关键代码：\n\n```C#\nTooltipForMap content = new TooltipForMap(tooltip, tooltipViewer);\n```\n\n其中 TooltipForMap 类的 SizeChanged 函数如下：\n\n```C#\nprivate void TooltipForMap_SizeChanged(object sender, SizeChangedEventArgs e)\n{\n    _TooltipViewer.Offset = new Point(-ActualWidth / 2, -ActualHeight - 22);\n}\n```\n\n`注意：`_TooltipViewer 和传入构造函数的 tooltipViewer 为同一实例。\n","tags":["Wpf","GMap.net"],"categories":["软件开发"]}]